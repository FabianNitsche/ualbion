using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UAlbion.Config;

namespace UAlbion.CodeGenerator
{
    public class EnumEntry
    {
        public string Name { get; set; }
        public int Value { get; set; }
        public override string ToString() => $"{Name} = {Value}";
    }

    public class EnumData
    {
        /// <summary>
        /// The fully qualified type name of the enum type
        /// </summary>
        public string FullName { get; set; }
        /// <summary>
        /// The underlying/backing type of the enum (byte, ushort, int, uint, long etc, or "non-generated" for non-autogenerated enums)
        /// </summary>
        public string EnumType { get; set; }
        /// <summary>
        /// The type of asset, identifies the purpose that the assets identified by the enum will be used for.
        /// </summary>
        public AssetType AssetType { get; set; }
        public string CopiedFrom { get; set; }
        public IList<EnumEntry> Entries { get; } = new List<EnumEntry>();
        string FullNameWithoutAssembly
        {
            get
            {
                int index = FullName.IndexOf(',');
                return index == -1 ? FullName : FullName.Substring(0, index);
            }
        }

        public string Namespace => FullName.Substring(0, FullNameWithoutAssembly.LastIndexOf('.'));
        public string TypeName => FullNameWithoutAssembly.Substring(FullNameWithoutAssembly.LastIndexOf('.') + 1);
        public Type Type => Type.GetType(FullName);
    }

    static class GenerateEnums
    {
        public static void Generate(Assets assets)
        {
            const string relativeOutputPath = @"src/Base"; // TODO: Pull from asset config
            var outputPath = Path.Combine(assets.BaseDir, relativeOutputPath);
            if (!Directory.Exists(outputPath))
                Directory.CreateDirectory(outputPath);

            // TODO: Extension methods from Base enums to AssetId, .ToId() or just .Id()?
            foreach (var e in assets.Enums.Values)
            {
                if (e.EnumType == "non-generated")
                    continue;

                File.WriteAllText(Path.Combine(outputPath, e.TypeName + ".g.cs"),
$@"// Note: This file was automatically generated using Tools/GenerateEnums.
// No changes should be made to this file by hand. Instead, the relevant json
// files should be modified and then GenerateEnums should be used to regenerate
// the various ID enums.
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
#pragma warning disable CA1707 // Identifiers should not contain underscores
namespace {e.Namespace}
{{
    [JsonConverter(typeof(StringEnumConverter))]
    public enum {e.TypeName} {(e.EnumType != null ? ":" : "")} {e.EnumType}
    {{
" +
                string.Join(Environment.NewLine, e.Entries.OrderBy(x => x.Value).Select(x => $"        {x.Name} = {x.Value},"))
                + $@"
    }}
}}
#pragma warning restore CA1707 // Identifiers should not contain underscores
");
            }
        }
    }
}
