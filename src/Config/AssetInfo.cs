using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace UAlbion.Config
{
    public class AssetInfo
    {
        [JsonIgnore] public int SubAssetId { get; internal set; } // Sub-asset offset in the container file (or 0 if not inside a container)
        [JsonIgnore] public AssetFileInfo File { get; set; }
        [JsonIgnore] public int EffectiveWidth => Width ?? File.Width ?? 0; // For sprites only
        [JsonIgnore] public int EffectiveHeight => Height ?? File.Height ?? 0; // For sprites only
        [JsonIgnore] public bool Transposed => File.Transposed ?? false; // For sprites only
        [JsonIgnore] public AssetId AssetId { get; internal set; }

        public int Id { get; set; } // Id of this asset in the mapped enum type.
        public string Name { get; set; } // Debug/console name of the asset, used to build the autogenerated enum types.
        public int? Width { get; set; } // For sprites only
        public int? Height { get; set; } // For sprites only

        [JsonExtensionData]
        public IDictionary<string, JToken> Properties { get; set; }

        public T Get<T>(string propertyName, T defaultValue)
        {
            if (Properties == null || !Properties.TryGetValue(propertyName, out var token))
                return defaultValue;

            return token.Value<T>();
        }

        public void Set<T>(string propertyName, T value)
        {
            Properties ??= new Dictionary<string, JToken>();
            if (value == null)
                Properties.Remove(propertyName);
            else
                Properties[propertyName] = new JValue(value);
        }

        public T[] GetArray<T>(string propertyName)
        {
            if (Properties == null || !Properties.TryGetValue(propertyName, out var token))
                return null;

            if (token is JArray array)
                return array.Select(x => x.Value<T>()).ToArray();

            return null;
        }

        public JToken GetRaw(string propertyName) => Properties != null && Properties.TryGetValue(propertyName, out var token) ? token : null;
    }
}
